\section{Implications}

Through our large-scale analysis of the collective knowledge of shell customization via aliases,
%of unique files that contain over 2.2 million alias definitions, 
we gained insight into practices detailing how users customize their command-line interface.
Based on our observations, we outline discussion points that go beyond single customization practices and identify implications that can address shortcomings in command-line usability and tie them to existing user experience research.
Further, while our presented findings already give us an understanding of customization practices over many different kinds of commands, we view our collected dataset as a playground for fine-grained discovery that can benefit researchers, tool builders, and command-line users.

\paragraph{Learning Repair Rules}

The complexity of commands and arguments can cause users to introduce errors when working in a command-line interface.
Figuring out specifically how to fix these errors is often a convoluted process.
A popular open source project that attempts to navigate this issue\footnote{\url{https://github.com/nvbn/thefuck}} uses a set of rules to suggest possible error corrections for commands.
While these rules are all hard-coded, we envision leveraging the global wisdom of customizations in our large-scale dataset to learn rules that form the basis for different kinds of suggestions.
This is in line with work in leveraging emergent behavior from corpora~\citep{fast:14} that we can codify based on our customization data.
%An obvious choice from our analysis are autocorrecting aliases to learn repair rules.

\paragraph{Discovering Workflows}
Following a different thread of leveraging emergent practices, we can also see how our dataset would enable a world beyond only trying to fix immediate errors, by providing usage hints that could introduce users to common parameters and workflows.
For example, as soon as a user tries to \cmd{sort} the output of the \cmd{ps} command, the alias \alias{mem10}{ps auxf | sort -nr -k 4 | head -10} can serve as a suggestion for the complex but common data transformation that results in showing the ten most memory-intensive processes.
%\paragraph*{\bf Object Protocols}
Similarly, in the practice of \emph{chaining subcommands} we can clearly see the prevalence of object protocols~\citep{beckman:11}, which are implicit rules determining the order in which commands have to be executed.
We can improve usability by enabling the discovery of these implicit rules and by exposing the dependency structure based on our customization data.
For instance, if executing \verb|brew upgrade| results in a failure, we can suggest using \verb|brew update && brew upgrade| instead, based on the patterns in our dataset. 

\paragraph{Uncovering Conceptual Design Flaws}

Customization can also be an indicator for problems in the underlying conceptual design, manifesting as usability frustrations that require adaptation by the user.
Briefly comparing our findings to the qualitative analysis on conceptual design flaws in \cmd{git} by \cite{perez:13}, we can clearly see the same frustrations with committing and switching branches,\footnote{``Just Let Me Commit!" and ``I Just Want to Switch Branches" in \cite{perez:13}} based on the alias definitions in our dataset (e.g., \alias{commit}{git add . \&\& git commit -m}).

We want to emphasize that we are not suggesting that large-scale quantitative data of customization practices can replace qualitative analysis, but rather that the corpus we provide, together with our findings, can support exploration and provide new insights for usability research.

\paragraph{Contextual Defaults}

Choosing proper defaults in user interfaces is a pillar of user experience design~\citep{nielsen2005power}.
The fact that \per{14.48} of the customizations in our dataset are for \emph{overriding defaults} suggests that, at least for some groups of users, the default settings of their tools could be improved.
We see \emph{overriding defaults} not necessarily as an indictment of the involved commands, but rather as an indication that the assumed user context does not in all cases match the actual usage profile.
Indeed, the variety of different defaults in the data indicate what we call \emph{contextual} defaults, where context could be a reflection of the level of expertise of a command-line user, or a certain persona (e.g., system administrator, data scientist, or software engineer).
We could imagine providing different sets of defaults to different users, effectively alias starter packs, generated from our data.
We see parallels to work that investigates contextual preferences and personalization in information systems~\citep{de:15, stefanidis:11} and privacy research~\citep{wijesekera:18, alom:19}. 

\paragraph{Interactivity vs Batch-Processing}

Context extends to the environment a command is executed in, particularly whether it is used on an interactive command line or as part of a script for batch-processing.
Our findings highlight the tension between these different ways of execution and how a human user can have needs different from an automated workflow.
This particularly comes to light in the customization practices of \emph{colorizing output} and \emph{overriding defaults}.
While human-readable output or prompting for destructive actions makes no sense in scripts and is usually seen as cumbersome for expert users even on the command line, our findings show that aliases like \alias{mv}{mv -i} are nonetheless highly desired by some.
