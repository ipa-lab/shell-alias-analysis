\section{Introduction}

A command line interface, also called a \emph{shell}, is a textual interface that allows users to interact with the underlying operating system by issuing commands.
Expert users, such as system administrators, software developers, researchers, and data scientists, routinely use the shell as it affords them flexibility and the ability to compose multiple commands.
They perform a variety of tasks on their systems including navigating and interacting with the filesystem (e.g., \cmd{ls}, \cmd{mv}, \cmd{cd}), using version control (e.g., \cmd{git}, \cmd{hg}), installing packages (e.g., \cmd{apt-get}, \cmd{npm}), or dealing with infrastructure (e.g., \cmd{docker}).
Experts can adapt and play with a multitude of commands and arguments, chaining them together to create more complex workflows.
All this versatility introduces a common problem in user interfaces of recognition over recall~\cite{nielsen:05}, where users have to recall the particularities of syntax and argument combinations, instead of enabling them to use a more recognizable symbol (as in graphical user interfaces).

A way for these experts to introduce recognizability and customize their command line experience is to attach a distinct name to potentially convoluted, but frequently used, command and argument structures.
This can be achieved by defining shell aliases.
An alias substitutes a given name, the \emph{alias}, with a string value that defines an arbitrarily complex command (or chain of commands).
The set of aliases users define provides a window into their preferences expressed as part of their personal configuration.
These command customizations can therefore provide insight into the tasks that they repeatedly perform, how well the standard environment supports those tasks, and ways in which this standard environment could be productively extended or modified.
Many users have publicly shared these configurations on social coding platforms such as GitHub.
To study these preferences, we performed an exploratory analysis of over 2.2 million alias definitions on GitHub, which provides a rich dataset to investigate how command-line users customize their tasks and workflows.

We find that there are three high-level types of customization practices:
\textsc{Shortcuts} introduce new names.
They can be used for \emph{nicknaming commands} (and correcting misspellings in the process),
\emph{abbreviating subcommands} like \texttt{git push},
and \emph{bookmarking locations} for quick navigation.
\textsc{Modifications} change the semantics of commands.
We can use these types of aliases for \emph{substituting commands}, such as replacing \cmd{more} with \cmd{less},
for \emph{overriding defaults} to customize commands to personal contexts, 
which often involves \emph{colorizing output},
and also running certain commands as root by \emph{elevating privilege}.
Aliases that combine multiple commands are \textsc{Scripts}.
They enable many ways of \emph{transforming data} using Unix pipes, 
and allow for automating repetitive workflows by \emph{chaining subcommands}.

Identifying these practices provides insight into usability issues of command-line interfaces.
We find that many customizations deal with the tension between commands being used to interactively navigate our systems, while at the same time being used within scripts for batch-processing.
We also find that many customizations redefine the default way particular commands are used, potentially indicating the need for contextualized defaults depending on user profiles and needs. 

We envision that our findings and dataset can be used to learn repair rules, in order to correct not only user errors, but also enable usage discovery to introduce newcomers to different argument structures and workflows within commands.
Further, while our presented findings already give us an understanding of customization practices over many different kinds of commands, we view our collected dataset as a playground for fine-grained discovery that can benefit researchers, tool builders, and command-line users.

In the following, we introduce more background by describing usage and syntax of aliases. We further describe our data collection and parsing process. We then present the findings from our exploratory analysis on customization practices expressed through these aliases, followed by a discussion on implications for usability. We finally discuss threats to validity and review related work in the broader context of this study. 