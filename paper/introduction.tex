\section{Introduction}

A command line interface, also called a \emph{shell}, is a textual interface that allows users to interact with the underlying operating system by issuing commands.
Expert users, such as system administrators, software developers, researchers, and data scientists, routinely use the shell as it affords them flexibility and the ability to compose multiple commands.
They perform a variety of tasks on their systems including navigating and interacting with the filesystem (e.g., \verb|ls|, \verb|mv|, \verb|cd|), using version control (e.g., \verb|git|, \verb|hg|), installing packages (e.g., \verb|apt-get|, \verb|npm|), or dealing with infrastructure (e.g., \verb|docker|).
Experts can adapt and play with a multitude of commands and arguments, chaining them together to create more complex workflows.
All this versatility introduces a common problem in user interfaces of recognition over recall~\cite{nielsen:05}, where users have to recall the particularities of syntax and argument combinations, instead of enabling them to use a more recognizable symbol (as in graphical user interfaces).

A way for these experts to introduce recognizability and customize their command line experience is to attach a distinct name to potentially convoluted, but frequently used, command and argument structures.
This can be achieved by defining shell aliases.
An alias substitutes a given name, the \emph{alias}, with a string value that defines an arbitrarily complex command (or chain of commands).
The set of aliases users define provides a window into their preferences expressed as part of their personal shell configuration.
Many users have publicly shared these configurations on social coding platforms such as GitHub.
To study these preferences, we performed an exploratory analysis of over 2.2 million alias definitions on GitHub, which provides a rich dataset to investigate how command line users customize their tasks and workflows.

We find that there are three types of aliases, supporting a number of customization practices:
\textsc{Shortcuts} introduce new names.
They can be used for \emph{nicknaming commands} (and correcting misspellings in the process),
\emph{abbreviating subcommands} like \texttt{git push},
and \emph{bookmarking locations} for quick navigation.
\textsc{Modifications} change the semantics of commands.
We can use these types of aliases for \emph{substituting commands}, such as replacing \cmd{more} with \cmd{less},
for \emph{overriding defaults} to customize commands to personal contexts, 
which often involves \emph{colorizing output},
and also running certain commands as root by \emph{elevating privilege}.
Aliases that combine multiple commands are \textsc{Scripts}.
They enable many ways of \emph{transforming data} using Unix pipes, 
and allow for automating repetitive workflows by \emph{chaining subcommands}.

\TODO Our insights can help improve the usability for particular tools and the command line experience in general.
Our results on default arguments indicate usability issues for a wide range of tools, but also shows that defaults can sometimes be contextual (e.g., \verb|-i| interactive mode by default in the command line, but not when executing scripts).
We also envision that our results and dataset can be used to learn repair rules, in order to correct not only user errors, but also provide usage hints to introduce newcomers to common workflows.

In the following, we introduce more background by describing usage and syntax of aliases. We further describe our data collection and parsing process. We then present the findings from our exploratory analysis on shell aliases in the wild, followed by a discussion on implications for usability. We finally discuss threats to validity and review related work in the broader context of this study. 