\section{Introduction}

A command-line interface, also called a \emph{shell}, is a textual interface that allows users to interact with the underlying operating system by issuing commands.
Expert users, such as system administrators, software developers, researchers, and data scientists, routinely use the shell as it affords them flexibility and the ability to compose multiple commands.
They perform a variety of tasks on their systems including navigating and interacting with the filesystem (e.g., \cmd{ls}, \cmd{mv}, \cmd{cd}), using version control (e.g., \cmd{git}, \cmd{hg}), installing packages (e.g., \cmd{apt-get}, \cmd{npm}), or dealing with infrastructure (e.g., \cmd{docker}).
Experts can adapt and play with a multitude of commands and arguments, chaining them together to create more complex workflows.
All this versatility introduces a common problem in user interfaces of recognition over recall~\citep{nielsen:05}, where users have to recall the particularities of syntax and argument combinations, instead of enabling them to use a more recognizable symbol (as in graphical user interfaces).

A way for these experts to introduce recognizability and customize their command-line experience is to attach distinct names to potentially convoluted, but frequently used, command and argument structures.
This can be achieved by defining shell aliases.
An alias substitutes a given name, the \emph{alias}, with a string value that defines an arbitrarily complex command (or chain of commands).
The set of aliases users define provides a window into their preferences expressed as part of their personal configuration.
Many users publicly share these configurations on social coding platforms such as GitHub, contributing to a collective knowledge of command-line customizations, which can provide insight into the tasks that expert users repeatedly perform, how well the standard environment supports those tasks, and ways in which this standard environment could be productively extended or modified.
To study these preferences, we performed an exploratory analysis on the population of alias definitions on GitHub. This paper makes the following contributions:

\begin{itemize}
	\item A \textbf{Curated Dataset of Command-Line Customizations}, consisting of over 2.2 million shell aliases collected from GitHub.
	We view our dataset as a playground for fine-grained discovery that can benefit researchers, tool-builders, and command-line users.
	We also describe the effective mining technique we used to distill this knowledge, which allowed us to capture almost the whole population (\per{94.09}) of relevant shell configuration files.
	\smallskip
	
	\item We identified nine \textbf{Customization Practices}, grouped into three high-level themes:
	\textsc{Shortcuts} introduce new names.
	They can be used for \emph{nicknaming commands} (and correcting misspellings in the process),
	\emph{abbreviating subcommands} like \texttt{git push},
	and \emph{bookmarking locations} for quick navigation.
	\textsc{Modifications} change the semantics of commands.
	We can use these types of aliases for \emph{substituting commands}, such as replacing \cmd{more} with \cmd{less},
	for \emph{overriding defaults} to customize commands to personal contexts, 
	which often involves \emph{colorizing output},
	and also running certain commands as root by \emph{elevating privilege}.
	Aliases that combine multiple commands are \textsc{Scripts}.
	They enable many ways of \emph{transforming data} using Unix pipes, 
	and allow for automating repetitive workflows by \emph{chaining subcommands}.
	\smallskip
	
	\item We formulate \textbf{Implications for Command-Line Usability} that go beyond single customization practices to address shortcomings and tie them to existing user experience research.
	Codifying emergent behavior~\citep{fast:14} found in our customizations enables \emph{learning repair rules} and \emph{discovering workflows}.
	We are able to \emph{uncover conceptual design flaws}, where customizations indicate frustrations with underlying command structures~\citep{perez:13}.
	Based on the prevalence of highly variable command redefinitions, we propose \emph{contextual defaults}, the ability to suggest different command preferences based on user context~\citep{stefanidis:11}.
	Overall, we find that many customizations deal with the tension of \emph{Interactivity vs Batch-Processing}: commands being used to interactively navigate systems, while at the same time being used within scripts for batch-processing.
\end{itemize}
We now describe usage and syntax of aliases as a vehicle for customization. We further describe our data collection and coding process, followed by a presentation of customization practices. Finally, we discuss implications for usability and review related work in the broader context of this study.